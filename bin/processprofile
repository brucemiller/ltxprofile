#!/usr/bin/perl -w
use strict;
use warnings;
use FindBin;
use lib "$FindBin::RealBin/../lib";
use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;
use YAML::Tiny;
use Data::Dumper;

#**********************************************************************
my $CONFIGDIR = "../lib/Profiles";
# Parse command line
my $verbosity;
my $splitback  = "//ltx:bibliography | //ltx:appendix | //ltx:index";
my %splitpaths = (
  part       => "//ltx:part | $splitback",
  chapter    => "//ltx:part | //ltx:chapter | $splitback",
  section    => "//ltx:part | //ltx:chapter | //ltx:section | $splitback",
  subsection => "//ltx:part | //ltx:chapter | //ltx:section | //ltx:subsection | $splitback",
  subsubsection => "//ltx:part | //ltx:chapter | //ltx:section | //ltx:subsection | //ltx:subsubsection | $splitback");

my $sawformat;
my $sawinputformat;
my $destination;
my $opts = {};    # not-yet-handled options.
# NOTE: Need provision for checking for allowed values of certain parameters?
#  Handled during command-line processing? during config parsing? during instanciation?
my @options = ();
sub add { push(@options, @_); }
sub Boole { return ($_[0] ? 'true' : 'false'); }
my $spec = {
  # Basics and Paths
  "output=s"      => sub { add("global:\n  destination: '$_[1]'"); $destination = $_[1]; },
  "destination=s" => sub { add("global:\n  destination: '$_[1]'"); $destination = $_[1]; },
  "base=s"      => sub { add("global:\n  basedir: '$_[1]'"); },      # how diff from sitedir?
  "log=s"       => sub { add("global:\n  log: '$_[1]'"); },
  "path=s"      => sub { add("global:\n  paths:\n  -'$_[1]'"); },
  "strict"      => sub { add("global:\n  strict: true"); },
  "preload=s"   => sub { add("digest:\n  preload: '$_[1]'"); },
  "preamble=s"  => sub { add("digest:\n  preamble: '$_[1]'"); },
  "postamble=s" => sub { add("digest:\n  postamble: '$_[1]'"); },
  "comments!"       => sub { add("digest:\n  includecomments: " . Boole($_[1])); },
  "documentid=s"    => sub { add("digest:\n  documentid: '$_[1]'"); },
  "includestyles"   => sub { add("digest:\n  includestyles: true"); },
  "inputencoding=s" => sub { add("digest:\n  inputencoding : '$_[1]'"); },
  "xml"             => sub { add("include: xml"); $sawformat = 1; },
  "tex" => sub { add("include: tex"); $sawformat = 1; },               # TeX OUTPUT!!!!
  "box"      => sub { add("include: box");   $sawformat      = 1; },
  "format=s" => sub { add("include: $_[1]"); $sawformat      = 1; },
  "bibtex"   => sub { add("include: bib");   $sawinputformat = 1; },
  "profile=s" => sub { add("include: '$_[1]'"); },
  "mode=s"    => sub { add("include: '$_[1]'"); },                     # alias for profile?
  "noparse"   => sub { add("mathparser:\n  enabled: false"); },
  "parse=s" => sub { add("mathparser:\n  enabled: true\n  engine: '$_[1]'"); },
  "cache_key=s" => \$$opts{cache_key},
  "source=s"    => \$$opts{source},
  "embed"       => sub { $$opts{whatsout} = 'fragment'; },
  "whatsin=s"   => \$$opts{whatsin},
  "whatsout=s"  => \$$opts{whatsout},
  "autoflush=i"              => sub { add("daemon:\n   input_limit: '$_[1]'"); },
  "timeout=i"                => sub { add("daemon:\n   timeout: '$_[1]'"); },
  "expire=i"                 => sub { add("daemon:\n   expire: '$_[1]'"); },
  "address=s"                => sub { add("daemon:\n   address: '$_[1]'"); },
  "port=i"                   => sub { add("daemon:\n   port: '$_[1]'"); },
  "post!"                    => \$$opts{post},
  "validate!"                => sub { add("post:\n   validate: " . Boole($_[1])); },
  "omitdoctype!"             => sub { add("post:\n   omitdoctype: " . Boole($_[1])); },
  "numbersections!"          => sub { add("post:\n   numbersections: " . Boole($_[1])); },
  "mathimages!"              => sub { add("mathimages:\n   enabled: " . Boole($_[1])); },
  "mathimagemagnification=f" => sub { add("mathimages:\n   magnification: '$_[1]'"); },
  "mathsvg!"                 => sub { add("mathsvg:\n   enabled: " . Boole($_[1])); },
  "linelength=i"             => sub { add("pmml:\n   linelength: $_[1]"); },
  "plane1!"                  => sub { add("pmml:\n   plane1: " . Boole($_[1])); },
  "hackplane1!"              => sub { add("pmml:\n   hackplane1: " . Boole($_[1])); },
  "presentationmathml|pmml!" => sub { add("pmml:\n   enabled: " . Boole($_[1])); },
  "contentmathml|cmml!"      => sub { add("cmml:\n   enabled: " . Boole($_[1])); },
  "openmath|om!"             => sub { add("om:\n   enabled: " . Boole($_[1])); },
  "keepXMath!"               => sub { add("xmath:\n   enabled: " . Boole($_[1])); },
  "mathtex!"                 => sub { add("mathtex:\n   enabled: " . Boole($_[1])); },
  "stylesheet=s"             => sub { add("xslt:\n  enabled: true\n  stylesheet: '$_[1]'"); },
  "xsltparameter=s"          => sub { add("xslt:\n  enabled: true\n  parameters:\n - '$_[1]'"); },
  "timestamp=s"              => sub { add("xslt:\n  timestamp: '$_[1]'"); },
  "defaultresources!"        => sub { add("xslt:\n  defaultresources: " . Boole($_[1])); },
  "css=s"                    => sub { add("xslt:\n  css:\n  - '$_[1]'"); },
  "javascript=s"             => sub { add("xslt:\n  javascript:\n  - '$_[1]'"); },
  "icon=s"                   => sub { add("xslt:\n  icon: '$_[1]'"); },
  "split!"                   => sub { add("split:\n  enabled: " . Boole($_[1])); },
  "splitat=s"                => sub { add("split:\n  enabled: true\n  splitat='$_[1]'"); },
  "splitpath=s"              => sub { add("split:\n  enabled: true\n  splitpath='$_[1]'"); },
  "splitnaming=s"            => sub { add("split:\n  enabled: true\n  splitnaming='$_[1]'"); },
  "scan!"                    => sub { add("scan:\n  enabled: true"); },
  "prescan"    => sub { add("scan:\n  enabled: true"); },           # AND disable other post!!!
  "crossref!"  => sub { add("crossref:\n  enabled: true"); },
  "urlstyle=s" => sub { add("crossref:\n  urlstyle: '$_[1]'"); },
  "navigationtoc|navtoc=s" => sub { add("crossref { navigation_toc: '$_[1]'"); },
  "index!"                 => sub { add("index:\n   enabled: " . Boole($_[1])); },
  "permutedindex!"         => sub { add("index:\n   permuted: true"); },
  "splitindex!"            => sub { add("index:\n   split: " . Boole($_[1])); },
  "bibliography=s"         => sub { add("bib:\n   bibliographies:\n  - '$_[1]'"); },
  "nobibliography"         => sub { add("bib:\n   enabled: false"); },
  "splitbibliography!"     => sub { add("bib:\n   split: " . Boole($_[1])); },
  "dbfile=s"               => sub { add("global:\n   dbfile: '$_[1]'"); },
  "sitedirectory=s"        => sub { add("global:\n   sitedirectory: '$_[1]'"); },
  "resourcedirectory=s"    => sub { add("global:\n   resourcedirectory: '$_[1]'"); },
  "sourcedirectory=s"      => sub { add("post:\n   sourcedir: '$_[1]'\n"); },
  "graphicimages!"         => sub { add("graphics:\n   enabled: " . Boole($_[1])); },
  "graphicsmap=s"  => \@{ $$opts{graphicsmaps} },
  "svg!"           => sub { add("svg:\n   enabled: " . Boole($_[1])); },
  "pictureimages!" => sub { add("pictureimages:\n   enabled: " . Boole($_[1])); },
  # HELP

  "quiet"   => sub { $verbosity--; },
  "verbose" => sub { $verbosity++; },

  "VERSION!" => \$$opts{showversion},
  "debug=s"  => \@{ $$opts{debug} },
  "help"     => \$$opts{help}
};

GetOptions(%$spec);

push(@options, "global:\n  verbosity: $verbosity") if $verbosity;

my $source = $ARGV[0];

my $yoptions = join("\n---\n", @options);
print "Options as YAML:\n", $yoptions;

our $config = {};
# Load base configuration
LoadConfigFile($config, 'LaTeXML');
# Load configuration implied by input & output formats
if (!$sawinputformat && $source && ($source =~ /\.(tex|bib)$/)) {
  LoadConfigFile($config, $1); }
if (!$sawformat && $destination && ($destination =~ /\.(\w+)$/)) {
  LoadConfigFile($config, $1); }
# Invoke the configuration (multiple yaml docs) implied by command-line options
MergeConfig($config, YAML::Tiny->read_string($yoptions));

print "Config: " . Dumper($config);
#======================================================================
# Parse a config file, merging it into $config
# Possible enhancements:
#   any config besides the base one should warn if assigning to an unassigned field?
#   base config could also contain field.type to specify the expected type?
sub LoadConfigFile {
  my ($config, $source) = @_;
  # just assume all are here, for now.
  my $path = $CONFIGDIR . '/' . $source . '.ltxcfg';
  if (-f $path) {
    MergeConfig($config, YAML::Tiny->read($path)); }
  else {
    warn "Missing config file $path\n"; } }

# Merge the $yaml data into $config
sub MergeConfig {
  my ($config, $yaml) = @_;
  #  print "MERGING configuration from ".Dumper($yaml);
  foreach my $ydoc (@$yaml) {    # multiple "documents" ??
    foreach my $name (keys %$ydoc) {
      my $value = $$ydoc{$name};
      if ($name eq 'include') {
        LoadConfigFile($config, $value); }
      else {
        mergeValue($config, $name, $value); } } } }

sub mergeValue {
  my ($object, $name, $value) = @_;
  my $prev     = $$object{$name};
  my $prevtype = ref $prev;
  my $type     = ref $value;
  # if($prev){
  #   print "MERGE $name => $value ($type) into $prev ($prevtype) in $object\n"; }
  # else {
  #   print "ASSIGN $name => $value ($type) in $object\n"; }
  if (!$prev) {    # Possible warning?
    $$object{$name} = $value; }
  elsif ($prevtype eq 'HASH') {
    if ($type eq 'HASH') {
      map { mergeValue($$object{$name}, $_, $$value{$_}) } keys %$value; }
    else {
      warn "cannot merge $value into $$object{$name}\n"; } }
  elsif ($prevtype eq 'ARRAY') {
    push(@{ $$object{$name} }, ($type eq 'ARRAY' ? @$value : $value)); }
  else {
    warn "Not sure what $$object{$name} is doing in configuration\n"; } }

#======================================================================
