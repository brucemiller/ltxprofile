#!/usr/bin/perl -w
use strict;
use warnings;
use FindBin;
use lib "$FindBin::RealBin/../lib";
use Getopt::Long qw(:config no_ignore_case);
use Pod::Usage;
use YAML::Tiny;
use Data::Dumper;
use Text::Wrap;

my $CONFIGDIR = "$FindBin::RealBin/../lib/Config";
#======================================================================
# Command line options translation
#======================================================================
# Parse command line
my $verbosity;
my $splitback  = "//ltx:bibliography | //ltx:appendix | //ltx:index";
my %splitpaths = (
  part       => "//ltx:part | $splitback",
  chapter    => "//ltx:part | //ltx:chapter | $splitback",
  section    => "//ltx:part | //ltx:chapter | //ltx:section | $splitback",
  subsection => "//ltx:part | //ltx:chapter | //ltx:section | //ltx:subsection | $splitback",
  subsubsection => "//ltx:part | //ltx:chapter | //ltx:section | //ltx:subsection | //ltx:subsubsection | $splitback");

my $sawformat;
my $sawinputformat;
my $destination;
my $opts = {};    # not-yet-handled options.
# NOTE: Need provision for checking for allowed values of certain parameters?
#  Handled during command-line processing? during config parsing? during instanciation?
my $nmaths = 0;
my @options = ();
sub inc { push(@options, 'include: '.$_[0]); }
sub incif { push(@options, 'includeif: '.$_[0]); }
sub set {
  my($key,$value)=@_;
  my @keys = ('settings',split(':', $key));
  push(@options,join("\n", map { (' 'x$_).$keys[$_].':' } 0..$#keys).' '.$value); }

sub Boole { return ($_[0] ? 'true' : 'false'); }
my $spec = {
  "output=s"      => sub {
    $destination = $_[1];
    if($destination =~ /\.(\w+)$/){ incif($1); }
    set("global:destination: '$_[1]'");; },
  "destination=s" => sub {
    $destination = $_[1];
    if($destination =~ /\.(\w+)$/){ incif($1); }
    set('global:destination',$_[1]); },
  "base=s"        => sub { set('global:basedir',$_[1]); }, # diff from sitedir?
  "log=s"         => sub { set('global:log',$_[1]); },
  "path=s"        => sub { set('global:paths',$_[1]); },
  "strict"        => sub { set('global:strict','true'); },
  "validate!"     => sub { set('global:validate', Boole($_[1])); },
  "preload=s"     => sub { set('digest:preload',$_[1]); },
  "preamble=s"    => sub { set('digest:preamble',$_[1]); },
  "postamble=s"   => sub { set('digest:postamble',$_[1]); },
  "comments!"     => sub { set('digest:includecomments',Boole($_[1])); },
  "documentid=s"  => sub { set('digest:documentid',$_[1]); },
  "includestyles" => sub { set('digest:includestyles','true'); },
  "inputencoding=s" => sub { set('digest:inputencoding',$_[1]); },
  "xml"             => sub { inc('xml'); $sawformat = 1; },
  "tex"             => sub { inc('tex'); $sawformat = 1; },         # TeX OUTPUT!!!!
  "box"             => sub { inc('box'); $sawformat = 1; },
  "format=s"        => sub { inc($_[1]); $sawformat = 1; },
  "bibtex"          => sub { inc('bib'); $sawinputformat = 1; },
  "profile=s"       => sub { inc($_[1]); },
  "mode=s"          => sub { inc($_[1]); },                     # alias
  "noparse"         => sub { set('mathparser:enabled', 'false'); },
  "parse=s" => sub { set('mathparser:enabled', 'true');
		     set('mathparser:engine',$_[1]); },
  "cache_key=s"              => \$$opts{cache_key},                                         # ?
  "source=s"                 => \$$opts{source},                                            # ?
  "embed"                    => sub { set('packager:whatsout','fragment'); },
  "whatsin=s"                => sub { set('global:whatsin',$_[1]); },                # global??
  "whatsout=s"               => sub { set('packager:whatsout',$_[1]); },
  "autoflush=i"              => sub { set('daemon:input_limit',$_[1]); },
  "timeout=i"                => sub { set('daemon:timeout',$_[1]); },
  "expire=i"                 => sub { set('daemon:expire',$_[1]); },
  "address=s"                => sub { set('daemon:address',$_[1]); },
  "port=i"                   => sub { set('daemon:port',$_[1]); },
  "post!"                    => sub { inc('post'); },
  "omitdoctype!"             => sub { set('writer:omitdoctype', Boole($_[1])); },
  "mathimages!"              => sub { set('mathimages:enabled', Boole($_[1])); },
  "mathimagemagnification=f" => sub { set('mathimages:magnification',$_[1]); },
  "mathsvg!"                 => sub { set('mathsvg:enabled', Boole($_[1])); },
  "linelength=i"             => sub { set('pmml:linelength', $_[1]); },
  "plane1!"                  => sub { set('pmml:plane1', Boole($_[1])); },
  "hackplane1!"              => sub { set('pmml:hackplane1', Boole($_[1])); },
  "presentationmathml|pmml!" => sub { set('pmml:enabled',Boole($_[1]));
				      set('pmml:position', $nmaths++) if $_[1]; },
  "contentmathml|cmml!"      => sub { set('cmml:enabled',Boole($_[1]));
				      set('cmml:position', $nmaths++) if $_[1]; },
  "openmath|om!"             => sub { set('om:enabled', Boole($_[1]));
				      set('om:position', $nmaths++) if $_[1]; },
  "keepXMath!"               => sub { set('xmath:enabled', Boole($_[1]));
				      set('xmath:position', $nmaths++) if $_[1]; },
  "mathtex!"                 => sub { set('mathtex:enabled', Boole($_[1]));
				      set('mathtex:position', $nmaths++) if $_[1]; },
  "stylesheet=s"             => sub { set('xslt:enabled','true');
				      set('xslt:stylesheet', $_[1]); },
  "xsltparameter=s"   => sub { set('xslt:enabled','true');
			       set('xslt:parameters',$_[1]); },
  "timestamp=s"       => sub { set('xslt:timestamp',$_[1]); },
  "defaultresources!" => sub { set('xslt:defaultresources', Boole($_[1])); },
  "css=s"             => sub { set('xslt:css',$_[1]); },
  "javascript=s"      => sub { set('xslt:javascript',$_[1]); },
  "icon=s"            => sub { set('xslt:icon', $_[1]); },
  "split!"            => sub { set('split:enabled', Boole($_[1])); },
	    "splitat=s"         => sub {
	      my $path = $splitpaths{ $_[1] };
    configWarning("Value not in [" . join(',', keys %splitpaths) . "]",
      $_[1], 'split', 'splitat') unless $path;
    set('split:enabled','true');
    set('split:splitpath',$path); },
  "splitpath=s"   => sub { set('split:enabled','true');
			   set('split:splitpath',$_[1]); },
  "splitnaming=s" => sub { set('split:enabled','true');
			   set('split:splitnaming',$_[1]); },
  "scan!"         => sub { set('scan:enabled', 'true'); },
  "prescan"    => sub { set("scan:enabled', true"); },           # AND disable other post!!!
  "crossref!"  => sub { set('crossref:enabled','true'); },
  "urlstyle=s" => sub { set('crossref:urlstyle',$_[1]); },
  "navigationtoc|navtoc=s" => sub { set('crossref:navigation_toc',$_[1]); },
  "numbersections!"        => sub { set('crossref:numbersections', Boole($_[1])); },
  "index!"                 => sub { set('index:enabled', Boole($_[1])); },
  "permutedindex!"         => sub { set('indexpermuted','true'); },
  "splitindex!"            => sub { set('indexsplit', Boole($_[1])); },
  "bibliography=s"         => sub { set('bibbibliographies', $_[1]); },
  "nobibliography"         => sub { set('bib:enabled', 'false'); },
  "splitbibliography!"     => sub { set('bib:split', Boole($_[1])); },
  "dbfile=s"               => sub { set('global:dbfile',$_[1]); },
  "sitedirectory=s"        => sub { set('global:sitedirectory',$_[1]); },
  "resourcedirectory=s"    => sub { set('global:resourcedirectory',$_[1]); },
  "sourcedirectory=s"      => sub { set('globalsourcedir',$_[1]); },
  "graphicimages!"         => sub { set('graphicsenabled', Boole($_[1])); },
  "graphicsmap=s" => sub {    # graphicsmap=srctype.desttype
    my ($src, $dest) = split(/\./, $_[1]);
    $dest = $src unless $dest;
    set('graphics:graphics_types', $src);
### Need fancy identation!!
#####    set('graphics:type_properties"  $src:\n        destination_type: $dest");
 },
  "svg!"           => sub { set('picturesvg:enabled', Boole($_[1])); },
  "pictureimages!" => sub { set('pictureimages: enabled', Boole($_[1])); },
  # HELP

  "quiet"   => sub { $verbosity--; },
  "verbose" => sub { $verbosity++; },

  "VERSION!" => \$$opts{showversion},
  "debug=s"  => \@{ $$opts{debug} },
  "help"     => \$$opts{help}
};

#======================================================================
GetOptions(%$spec);
my $source = $ARGV[0];

# Add a couple of special case options
# If format explicitly given, remove "includif: $format" from @options
if ($sawformat){
  @options = grep { $_ !~ /^includeif:/ } @options; }
# Load configuration implied by input & output formats.
if (!$sawinputformat && $source && ($source =~ /\.(tex|bib)$/)) {
  unshift(@options, "include: $1"); }
unshift(@options, "settings: global:\n    verbosity: $verbosity") if $verbosity;

#======================================================================
my $yoptions = join("\n---\n", @options) . "\n";
print "Options as YAML:\n$yoptions\n";

our $config = LoadConfiguration($yoptions);

#print "Config: " . Dumper($config);
makePlan($config);

#======================================================================
# The known Processing Phases
our @PHASES;

BEGIN {
  # Try to condense this a bit more? (using sensible "position" values to sort within phases)
  # And, not yet configurable either!!
  @PHASES = (qw(
      digestion
      splitting
      scanning
      crossreferencing
      graphicstranslation
      mathtranslation
      xslt
      packaging));
}
#======================================================================
sub LoadConfiguration {
  my ($options) = @_;    # options in YAML form
  my $config = {};
  # Load base configuration
  loadConfigFile($config, 'LaTeXML');
  # Could load a user-configuration file?

  # Now invoke the configuration (multiple yaml docs) implied by command-line options
  mergeConfig($config, YAML::Tiny->read_string($options));
  # Special case for mathtranslation
  my @m = grep { (($$config{settings}{$_}{phase}||'') eq 'mathtranslation') }
    keys %{$$config{settings}};
  # If we have enabled mathtranslations, remove enabled from defaults before applying
  if(grep { (($$config{settings}{$_}{enabled}||'') eq 'true') } @m){
    map { $$config{defaults}{$_}{enabled} = 'false' } @m; }

  applyDefaults($config,$$config{defaults});
  return $config; }

sub loadConfigFile {
  my ($config, $source, $iffound) = @_;
  local $LaTeXML::CONFIG_FILE = $source;
  # Eventually search for config files
  my $path = $CONFIGDIR . '/' . $source . '.ltxcfg';
  if (-f $path) {
    print "Loading configuration $source ($path)\n";
    mergeConfig($config, YAML::Tiny->read($path)); }
  elsif (!$iffound) {
    warn "Missing config file $path\n"; } }

# Merge the $yaml data into $config
sub mergeConfig {
  my ($config, $yaml) = @_;
  if (!$yaml) {
    warn "Yaml error: " . YAML::Tiny->errstr . "\n"; }
  foreach my $ydoc (@$yaml) {    # foreach yaml "document"
    foreach my $name (keys %$ydoc) {
      my $value = $$ydoc{$name};
      if ($name eq 'include') {
        loadConfigFile($config, $value); }
      elsif ($name eq 'includeif') { # but we shouldn't make an error...
        loadConfigFile($config, $value, 1); }
      else {
        mergeValue($config, $value, $name); } } } }

sub mergeValue {
  my ($config, $value, @keys) = @_;
  my $object = configLookup($config, @keys[0 .. $#keys - 1]);
  my $key    = $keys[-1];
  my $prev   = $$object{$key};
  my $struct = 'scalar';    # the type of structure to maintain in $config: HASH, ARRAY, scalar
  # definition block gets special treatmen
  if ($keys[0] eq 'definition') {
    # Possible type-checking of type specifiers?
    $struct = (ref $prev) || (ref $value); }    # previous structure, or copy from $value
  # defaults block also
  elsif ($keys[0] eq 'defaults') { # Just merge into defaults tree, no type checking(?)
    $struct = (ref $prev) || (ref $value); }    # previous structure, or copy from $value
  elsif (my $type = configLookup($config, 'definition', @keys[1..$#keys])) {
    # $type can be hash for intermediate levels, else a declared type.
    $struct = (ref $type) || ($type =~ /^list\[/ ? 'ARRAY' : 'scalar');
    return if (!ref $type) && !configCheckType($type, $value, @keys); }
  else {
    configWarning("Unknown key (possible typo?)", $value, @keys);
    return; }
  if ($struct eq 'HASH') {
    $$object{$key} = {} unless $prev;           # initialize if needed
    if (!defined $value) { }
    elsif (ref $value eq 'HASH') {
      map { mergeValue($config, $$value{$_}, @keys, $_) } keys %$value; }
    else {
      configWarning("Cannot merge value into mapping", $value, @keys); } }
  elsif ($struct eq 'ARRAY') {
    $$object{$key} = [] unless $prev;           # initialize if needed
    if (defined $value) {
      push(@{ $$object{$key} }, (ref $value eq 'ARRAY' ? @$value : $value)); } }
  else {
    $$object{$key} = $value; } }

sub applyDefaults {
  my ($config, $default, @keys) = @_;
  my $object = configLookup($config, 'settings', @keys[0 .. $#keys - 1]);
  my $key    = $keys[-1];
  my $exists = $key && ! exists $$object{$key};
  if(ref $default eq 'HASH'){     # if hash, we're still descending.
    $$object{$key} = {} if $exists; # initialize if needed.
    map { applyDefaults($config, $$default{$_}, @keys, $_) } keys %$default; }
  elsif($exists){
    $$object{$key} = $default; }  # No previous value, assign default.
  return; }

# sorta like $$config{key1}{key2}...{keyn}
sub configLookup {
  my ($config, @keys) = @_;
  my $object = $config;
  map { $object = $object && $$object{$_} } @keys;
  return $object; }

# This could evolve to return the "normalized" $value?
sub configCheckType {
  my ($type, $value, @keys) = @_;
  # pathname, boolean, int, string, phasename, classname, date
  # or list[$type], hash[$ignored], choice[lit1,lit2...]
  if    ($type eq 'boolean') { return 1 if $value =~ /^(?:true|false)$/; }
  elsif ($type eq 'int')     { return 1 if $value =~ /^(?:\+|\-)?\d+$/; }
  elsif ($type eq 'string')  { return 1; }
  elsif ($type eq 'pathname')  { return 1; }
  elsif ($type eq 'classname') { return 1 if $value =~ /^(\w+)(?:\:\:\w+)*$/; }
  elsif ($type eq 'phasename') { return 1 if grep { $value eq $_ } @PHASES; }
  elsif ($type eq 'date') { return 1 if $value =~ /^\d{4}-\d{2}-\d{2}$/; }
  elsif ($type =~ /^list\[(\w+)\]$/) {
    my $subtype = $1;
    if (((ref $value) || '') eq 'ARRAY') {
      return 1 if !grep { !configCheckType($subtype, $_, @keys) } @$value; }
    else {
      return 1 if configCheckType($subtype, $value, @keys); } }
  elsif ($type =~ /^hash\[(\w*)\]$/) {
    # No checking of internal structure of the hash ... YET!
    return 1 if ((ref $value) || '') eq 'HASH'; }
  elsif ($type =~ /^choice\[(.*)\]$/) {
    my @choices = split(/\s*,\s*/, $1);
    return 1 if grep { $value eq $_ } @choices; }
  else {
    configWarning("Unknown type $type", $value, @keys);
    return 0; }
  configWarning("Value not of type $type", $value, @keys);
  return 0; }

sub configWarning {
  my ($message, $value, @keys) = @_;
  warn "Config warning in " . ($LaTeXML::CONFIG_FILE || 'commandline options') . ": $message\n"
    . " for " . join('->', @keys) . " = $value\n"; }

#======================================================================
# Analyzing the resulting configuration to generate a Processing Plan
# Note current code doesn't support this level of abstraction,
# although it is similar to the post-processing chain.
sub makePlan {
  my ($config) = @_;
  my $settings = $$config{settings};
  print "Global: " . minidump($$settings{global}) . "\n";
  print "Daemon: " . minidump($$settings{daemon}) . "\n";
  my @processors = ();
  foreach my $phase (@PHASES) {
    my @p = sort { ($$settings{$a}{position} || 0) <=> ($$settings{$b}{position} || 0) }
      grep { (($$settings{$_}{phase} || '') eq $phase) && (($$settings{$_}{enabled} || '') eq 'true') }
      keys %$settings;
    push(@processors, @p); }
  print "Processing plan:\n";
  foreach my $p (@processors) {
    print "$p : " . minidump($$settings{$p}) . "\n"; }
}

# Just for debugging the plan construction...
sub minidump {
  return wrap("", "         ", minidump_aux($_[0])); }

sub minidump_aux {
  my ($value) = @_;
  my $ref = ref $value;
  if (!$ref) {
    return (defined $value ? $value : 'undef'); }
  elsif ($ref eq 'HASH') {
    return '{' . join(', ', map { $_ . '=>' . minidump($$value{$_}) } sort keys %$value) . '}'; }
  elsif ($ref eq 'ARRAY') {
    return '[' . join(', ', map { minidump($_) } @$value) . ']'; } }

#======================================================================
